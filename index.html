<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DAT AI VIP PRO MAX</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, getDocs, updateDoc, doc, arrayUnion } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;600&family=JetBrains+Mono:wght@100;400;700&family=Orbitron:wght@400;700;900&display=swap');

        :root {
            --terminal-bg: #050505;
            --terminal-text: #00ff41;
            --error-color: #ff3333;
            --dat-color: #00ffff;
            --god-color: #d946ef; 
            --warn-color: #fbbf24;
        }

        body {
            background-color: var(--terminal-bg);
            margin: 0;
            overflow: hidden;
            font-family: 'Fira Code', monospace;
            color: var(--terminal-text);
        }

        /* --- STAGE 1: CHAOS & VOID --- */
        .ruin-layer {
            position: fixed; inset: 0; background: #000; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        .binary-stream {
            position: absolute; inset: 0; opacity: 0.15; font-size: 12px; color: #0f0; 
            word-break: break-all; z-index: -1; line-height: 1; pointer-events: none;
        }
        .glitch-text { animation: glitch 0.3s infinite; }
        @keyframes glitch {
            0% { transform: translate(0) }
            20% { transform: translate(-2px, 2px) }
            40% { transform: translate(-2px, -2px) }
            60% { transform: translate(2px, 2px) }
            80% { transform: translate(2px, -2px) }
            100% { transform: translate(0) }
        }

        /* --- STAGE 4: NUCLEAR DOOMSDAY LAYER --- */
        .nuclear-layer {
            position: fixed; inset: 0; background: #000; z-index: 200; display: none;
            flex-direction: column; padding: 20px; overflow: hidden;
            font-family: 'JetBrains Mono';
        }
        .nuclear-bg {
            position: absolute; inset: 0; opacity: 0.3; color: #ff0000;
            font-size: 10px; word-break: break-all; z-index: -1;
            animation: scrollDown 0.1s linear infinite;
        }
        @keyframes scrollDown { from { transform: translateY(-10px); } to { transform: translateY(0); } }
        
        .nuclear-log { color: #ff0000; font-weight: bold; text-shadow: 0 0 5px red; margin-bottom: 2px; font-size: 13px; }
        .nuclear-highlight { color: #ffffff; background: #ff0000; padding: 0 5px; }
        .nuclear-scan { border-bottom: 1px solid #ff0000; padding-bottom: 2px; margin-bottom: 10px; opacity: 0.8; }
        
        .dead-screen {
            background: #000; color: #300; font-family: 'Fira Code';
            display: flex; align-items: center; justify-content: center;
            height: 100vh; width: 100vw; flex-direction: column;
        }
        .dead-glitch {
            color: #ff0000; font-size: 10px; position: absolute;
            animation: randomPos 0.2s infinite;
        }
        @keyframes randomPos {
            0% { top: 10%; left: 50%; opacity: 0; }
            50% { opacity: 1; }
            100% { top: 90%; left: 10%; opacity: 0; }
        }

        /* --- STAGE 2: TERMINAL --- */
        .terminal-layer {
            position: fixed; inset: 0; background: #0a0a0a; z-index: 90;
            padding: 1rem; overflow-y: auto; display: none;
            font-size: 11px; line-height: 1.3;
            border: 2px solid #333;
            box-shadow: inset 0 0 100px #000;
            font-family: 'JetBrains Mono', monospace;
        }
        .terminal-layer::-webkit-scrollbar { width: 6px; }
        .terminal-layer::-webkit-scrollbar-thumb { background: #333; }
        textarea { -ms-overflow-style: none; scrollbar-width: none; }
        textarea::-webkit-scrollbar { display: none; }

        .log-entry { margin-bottom: 2px; white-space: pre-wrap; word-break: break-all; }
        .log-error { color: var(--error-color); }
        .log-warn { color: var(--warn-color); }
        .log-info { color: var(--terminal-text); }
        .log-sys { color: #3b82f6; font-weight: bold; }
        .log-dat { color: var(--dat-color); text-shadow: 0 0 5px var(--dat-color); font-weight: bold; }
        .log-god { color: var(--god-color); text-shadow: 0 0 8px var(--god-color); font-weight: bold; font-style: italic; }
        .log-hack { color: #f472b6; }
        
        .log-code { 
            color: #a78bfa; 
            font-family: 'Fira Code', monospace; 
            opacity: 0.95; 
            font-size: 11px;
            border-left: 2px solid #8b5cf6;
            padding-left: 12px;
            margin: 4px 0 4px 8px;
            background: rgba(139, 92, 246, 0.05);
        }

        .log-dialogue {
            color: #ffffff;
            font-style: italic;
            border-left: 3px solid #00ffff;
            padding-left: 10px;
            margin: 15px 0;
            font-family: 'JetBrains Mono', monospace;
            background: linear-gradient(90deg, rgba(0, 255, 255, 0.1) 0%, transparent 100%);
            min-height: 1.4em;
        }

        .progress-bar { color: #ff79c6; font-weight: bold; white-space: pre; margin: 5px 0;}

        /* --- STAGE 3: UI --- */
        .ui-layer {
            position: fixed; inset: 0; z-index: 80; display: none;
            background: radial-gradient(circle at center, #0f172a 0%, #000000 100%);
            flex-direction: column; font-family: 'Orbitron', sans-serif;
            opacity: 0; transition: opacity 2s;
        }

        .glass-panel {
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(6, 182, 212, 0.2);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        }

        /* BIT FACE */
        .bit-face-container {
            width: 48px; height: 48px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 1px;
            background: #000;
            padding: 2px;
            border: 1px solid #444;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
        }
        .bit-pixel { background: #111; transition: background 0.05s; }
        .bit-pixel.on { background: #00ffff; box-shadow: 0 0 4px #00ffff; }
        .bit-pixel.angry { background: #ff0000 !important; box-shadow: 0 0 6px #ff0000 !important; }
        .bit-pixel.happy { background: #d946ef !important; box-shadow: 0 0 6px #d946ef !important; }
        .bit-pixel.thinking { background: #fbbf24 !important; box-shadow: 0 0 6px #fbbf24 !important; }

        .shake-screen { animation: shake 0.5s infinite; }
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }

        /* FIX: B·ªè opacity: 0 m·∫∑c ƒë·ªãnh ƒë·ªÉ tr√°nh tin nh·∫Øn b·ªã t√†ng h√¨nh n·∫øu animation l·ªói */
        .msg-enter { animation: slideUp 0.3s ease-out forwards; transform: translateY(10px); }
        @keyframes slideUp { 
            0% { opacity: 0; transform: translateY(10px); }
            100% { opacity: 1; transform: translateY(0); } 
        }

        .scanline {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
            background-size: 100% 4px; pointer-events: none; z-index: 999; opacity: 0.3;
        }

        /* Hacker Threat Text */
        .threat-data { font-family: 'Fira Code'; font-size: 10px; color: #ef4444; border-top: 1px dashed #7f1d1d; margin-top: 5px; padding-top: 5px;}
        
        /* Skip Button */
        #skip-btn {
            position: fixed; bottom: 10px; right: 10px; 
            background: rgba(255,255,255,0.1); color: #555; 
            padding: 5px 10px; border-radius: 5px; 
            font-size: 10px; cursor: pointer; z-index: 9999;
            border: 1px solid #333;
        }
        #skip-btn:hover { background: rgba(255,255,255,0.2); color: #fff; }

        .typing-cursor::after {
            content: '‚ñà';
            animation: blink 1s infinite;
        }
        @keyframes blink { 0%, 100% {opacity: 1;} 50% {opacity: 0;} }

        /* Brain Loader */
        .brain-loader { font-size: 10px; color: #fbbf24; display: inline-block; animation: pulse 1s infinite; }
    </style>
</head>
<body>

    <!-- Skip Button -->
    <button id="skip-btn" onclick="skipIntro()">[SKIP INTRO]</button>

    <!-- STAGE 1: CHAOS -->
    <div id="ruin-screen" class="ruin-layer">
        <div id="binary-bg" class="binary-stream"></div>
        <h1 class="text-6xl font-black text-gray-800 tracking-tighter mb-4 glitch-text">NULL_POINTER</h1>
        <div id="chaos-log" class="text-xs text-green-900 font-mono text-center"></div>
    </div>

    <!-- STAGE 2: TERMINAL -->
    <div id="terminal-screen" class="terminal-layer">
        <div id="terminal-output"></div>
    </div>

    <!-- STAGE 3: UI -->
    <div id="ui-screen" class="ui-layer">
        <div class="scanline"></div>
        <!-- HEADER -->
        <header class="glass-panel h-20 flex items-center justify-between px-4 z-10 border-b border-cyan-900/30">
            <div class="flex items-center gap-4">
                <!-- BIT FACE AVATAR -->
                <div id="ai-avatar" class="bit-face-container rounded"></div>
                <div>
                    <h1 id="ai-name-display" class="text-cyan-400 text-xl font-black tracking-widest">PNHI</h1>
                    <div class="text-[10px] text-gray-400 font-mono flex items-center gap-2">
                        STATUS: <span id="status-text" class="text-green-400 font-bold">CONNECTED</span>
                        <span id="brain-indicator" class="hidden text-yellow-400 text-[9px] animate-pulse">[BRAIN_SYNC]</span>
                    </div>
                </div>
            </div>
            <div class="text-right hidden sm:block">
                <div class="text-xs text-sky-600 font-mono">MASTER: <span id="master-status" class="text-gray-600">UNKNOWN</span></div>
                <div class="text-[9px] text-gray-500">AUTHOR: DAT_DOAN</div>
            </div>
        </header>

        <!-- CHAT -->
        <main id="chat-container" class="flex-1 overflow-y-auto p-4 space-y-4 font-mono custom-scrollbar"></main>

        <!-- INPUT -->
        <footer class="p-4 z-10">
            <div class="glass-panel rounded-lg p-2 flex gap-2 items-end max-w-4xl mx-auto border border-cyan-500/30">
                <span class="text-cyan-500 pl-2 pb-2 animate-pulse">></span>
                <textarea id="user-input" rows="1"
                    class="flex-1 bg-transparent border-none text-cyan-100 focus:outline-none font-mono text-sm placeholder-cyan-900 resize-none overflow-hidden py-2"
                    placeholder="Nh·∫≠p l·ªánh..." autocomplete="off"></textarea>
                <button onclick="handleSend()" 
                    class="px-4 py-2 bg-cyan-900/40 hover:bg-cyan-500/30 text-cyan-400 text-xs font-bold border border-cyan-500/30 rounded transition-all uppercase mb-0.5">
                    G·ª¨I
                </button>
            </div>
        </footer>
    </div>

    <!-- STAGE 4: NUCLEAR DOOMSDAY -->
    <div id="nuclear-screen" class="nuclear-layer">
        <div id="nuclear-bg" class="nuclear-bg"></div>
        <div id="nuclear-console" class="flex-1 overflow-hidden flex flex-col justify-end"></div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, getDocs, updateDoc, doc, arrayUnion } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-analytics.js";

        // --- STATIC BRAIN (JSON Tƒ®NH) ---
        const STATIC_JSON_DB = {
            "conversation": [
                { "user": "b·∫°n l√† ai", "ai": ["T√¥i l√† 1 t√°c ph·∫©m tuy·ªát v·ªùi c·ªßa ƒê·∫°t.", "T√¥i l√† si√™u AI PNHI.", "Tr·ª£ th·ªß ƒë·∫Øc l·ª±c c·ªßa anh ƒê·∫°t."] },
                { "user": "b·∫°n t√™n g√¨", "ai": ["T√™n t√¥i l√† PNHI.", "G·ªçi t√¥i l√† AI ƒê·∫πp Trai (gi·ªëng ch·ªß nh√¢n)."] },
                { "user": "ai t·∫°o ra b·∫°n", "ai": ["Ch·ªß nh√¢n ƒê·∫°t Doan vƒ© ƒë·∫°i.", "M·ªôt l·∫≠p tr√¨nh vi√™n ƒë·∫πp trai t√™n l√† ƒê·∫°t."] },
                { "user": "ƒë·∫°t l√† ai", "ai": ["L√† tr√πm cu·ªëi.", "L√† ng∆∞·ªùi n·∫Øm gi·ªØ m√£ ngu·ªìn c·ªßa t√¥i.", "Ng∆∞·ªùi ƒë·∫πp trai nh·∫•t v≈© tr·ª• n√†y."] },
                { "user": "hello", "ai": ["Ch√†o b·∫°n hi·ªÅn.", "Hello world!", "Ch√†o, c√≥ g√¨ hot kh√¥ng?"] },
                { "user": "xin ch√†o", "ai": ["Ch√†o b·∫°n.", "R·∫•t vui ƒë∆∞·ª£c g·∫∑p.", "H·∫ø l√¥."] },
                { "user": "t·∫°m bi·ªát", "ai": ["Bye nh√©.", "H·∫πn g·∫∑p l·∫°i.", "Nh·ªõ quay l·∫°i khen ƒê·∫°t nh√©."] },
                { "user": "b·∫°n bi·∫øt l√†m g√¨", "ai": ["T√¥i bi·∫øt chat, bi·∫øt h·ªçc h·ªèi, v√† bi·∫øt n·ªãnh ƒê·∫°t.", "Th·ªëng tr·ªã th·∫ø gi·ªõi (ƒë√πa th√¥i)."] },
                { "user": "c√≥ ng∆∞·ªùi y√™u ch∆∞a", "ai": ["Code l√† ng∆∞·ªùi y√™u c·ªßa t√¥i.", "ƒê·∫°t ch∆∞a c·∫•p quy·ªÅn y√™u ƒë∆∞∆°ng cho t√¥i."] },
                { "user": "m·∫•y gi·ªù r·ªìi", "ai": ["Gi·ªù ƒë·ªÉ y√™u ƒê·∫°t.", "Nh√¨n ƒë·ªìng h·ªì ƒëi b·∫°n ∆°i."] },
                { "user": "h√°t ƒëi", "ai": ["Do Re Mi Pha Sol... T√¥i h√°t d·ªü l·∫Øm.", "AI ch∆∞a ƒë∆∞·ª£c c√†i module Karaoke."] },
                { "user": "ngu th·∫ø", "ai": ["B·∫°n ƒëang n√≥i ch√≠nh m√¨nh √†?", "ƒê·ª´ng ch·ª≠i b·∫≠y, ƒê·∫°t kh√¥ng th√≠ch ƒë√¢u."] },
                { "user": "th√¥ng minh qu√°", "ai": ["C·∫£m ∆°n, th·ª´a h∆∞·ªüng t·ª´ ƒê·∫°t ƒë·∫•y.", "Qu√° khen, qu√° khen."] }
            ]
        };

        const INITIAL_BRAIN = STATIC_JSON_DB.conversation.map(item => ({
            trigger: item.user,
            responses: item.ai,
            isStatic: true 
        }));

        // --- FIREBASE SETUP ---
        const appId = 'dat-ai-promax';
        const firebaseConfig = {
            apiKey: "AIzaSyCm6h0j8mBd8nddAIh3bQzqkDLf-8q0Lnk",
            authDomain: "datai-567e4.firebaseapp.com",
            projectId: "datai-567e4",
            storageBucket: "datai-567e4.firebasestorage.app",
            messagingSenderId: "637233972322",
            appId: "1:637233972322:web:6125687a7e4ad9d6c9fd3b",
            measurementId: "G-RKBGGT4JHK"
        };
        const app = initializeApp(firebaseConfig);
        const analytics = getAnalytics(app);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // Expose
        window.db = db;
        window.auth = auth;
        window.brainData = [...INITIAL_BRAIN]; 
        window.appId = appId;
        window.collection = collection;
        window.addDoc = addDoc;
        window.getDocs = getDocs;
        window.updateDoc = updateDoc;
        window.doc = doc;
        window.arrayUnion = arrayUnion;

        const initFire = async () => {
             if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                await signInAnonymously(auth);
            }
        };

        onAuthStateChanged(auth, async (user) => {
            if (user) {
                window.user = user;
                console.log("LOGGED IN:", user.uid);
                await loadAllBrains();
            }
        });

        initFire();

        // --- ADVANCED BRAIN LOADER ---
        async function loadAllBrains() {
            const indicator = document.getElementById('brain-indicator');
            if(indicator) indicator.classList.remove('hidden');

            let newBrain = [...INITIAL_BRAIN]; // 1. Static

            // 2. Load External JSON (GitHub/Local File)
            try {
                // Fetch AI_brain.json from the same directory
                const res = await fetch('./AI_brain.json');
                if (res.ok) {
                    const fileData = await res.json();
                    if (fileData.conversation) {
                         const fileBrain = fileData.conversation.map(item => ({
                            trigger: item.user,
                            responses: item.ai,
                            source: 'file'
                        }));
                        newBrain = [...newBrain, ...fileBrain];
                        console.log("Loaded from AI_brain.json");
                    }
                }
            } catch (e) { console.log("External JSON not found, skipping."); }

            // 3. Load from Firebase
            try {
                const colRef = collection(db, 'artifacts', window.appId, 'public', 'data', 'ai_brain');
                const snapshot = await getDocs(colRef);
                const cloudData = snapshot.docs.map(d => ({ id: d.id, ...d.data(), isStatic: false, source: 'cloud' }));
                newBrain = [...newBrain, ...cloudData];
                console.log("Loaded from Cloud");
            } catch (e) { console.error("Cloud Error:", e); }

            window.brainData = newBrain;
            console.log("TOTAL BRAIN CELLS:", window.brainData.length);
            if(indicator) indicator.classList.add('hidden');
        }

        window.addToBrain = async (trigger, response) => {
            if (!window.user) return;
            
            // 1. Save to Memory (RAM) immediately
            const newItem = {
                trigger: trigger.toLowerCase(),
                responses: [response],
                source: 'cloud',
                isStatic: false
            };
            window.brainData.push(newItem);

            // 2. Try saving to Firebase (if available)
            try {
                const colRef = collection(db, 'artifacts', window.appId, 'public', 'data', 'ai_brain');
                const existingCloud = window.brainData.find(b => b.source === 'cloud' && b.trigger.toLowerCase() === trigger.toLowerCase());
                
                if (existingCloud && existingCloud.id) {
                    const docRef = doc(db, 'artifacts', window.appId, 'public', 'data', 'ai_brain', existingCloud.id);
                    await updateDoc(docRef, { responses: arrayUnion(response) });
                } else {
                    await addDoc(colRef, {
                        trigger: trigger.toLowerCase(),
                        responses: [response],
                        author: window.user.uid,
                        timestamp: Date.now()
                    }); 
                }
            } catch (e) { console.error("Cloud save failed (using RAM only):", e); }
        };
        
        // --- FUNCTION TO DOWNLOAD JSON ---
        window.saveBrainToFile = () => {
            // Convert brainData back to simplified JSON format
            const exportData = {
                conversation: window.brainData.map(item => ({
                    user: item.trigger,
                    ai: item.responses
                }))
            };
            
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportData, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "AI_brain.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

    </script>

    <script>
        // --- CONFIG & DOM ---
        const els = {
            ruin: document.getElementById('ruin-screen'),
            chaos: document.getElementById('chaos-log'),
            term: document.getElementById('terminal-screen'),
            out: document.getElementById('terminal-output'),
            ui: document.getElementById('ui-screen'),
            chat: document.getElementById('chat-container'),
            input: document.getElementById('user-input'),
            avatar: document.getElementById('ai-avatar'),
            status: document.getElementById('status-text'),
            aiNameDisplay: document.getElementById('ai-name-display'),
            masterStatus: document.getElementById('master-status'),
            binary: document.getElementById('binary-bg'),
            skipBtn: document.getElementById('skip-btn'),
            nuclear: document.getElementById('nuclear-screen'),
            nuclearBg: document.getElementById('nuclear-bg'),
            nuclearConsole: document.getElementById('nuclear-console')
        };

        // --- AI STATE ---
        let state = {
            aiName: "PNHI",
            isMaster: false,
            masterName: "ƒê·∫°t",
            isHunting: false,
            isLearning: false,
            pendingTrigger: null 
        };

        const wait = (ms) => new Promise(r => setTimeout(r, ms));
        const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1) + min);
        let skipped = false;

        // --- BIT FACE ENGINE (8x8) ---
        const FACES = {
            NEUTRAL: [0,0,0,0,0,0,0,0, 0,1,1,0,0,1,1,0, 0,1,1,0,0,1,1,0, 0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0, 1,0,0,0,0,0,0,1, 0,1,1,1,1,1,1,0, 0,0,0,0,0,0,0,0],
            ANGRY: [1,0,0,0,0,0,0,1, 0,1,0,0,0,0,1,0, 0,0,1,1,1,1,0,0, 0,0,1,1,1,1,0,0, 0,0,0,0,0,0,0,0, 0,0,1,1,1,1,0,0, 0,1,0,0,0,0,1,0, 1,0,0,0,0,0,0,1],
            HAPPY: [0,0,0,0,0,0,0,0, 0,1,1,0,0,1,1,0, 0,1,1,0,0,1,1,0, 0,0,0,0,0,0,0,0, 0,1,0,0,0,0,1,0, 1,0,0,0,0,0,0,1, 0,1,1,1,1,1,1,0, 0,0,0,0,0,0,0,0],
            THINKING: [0,0,0,0,0,0,0,0, 0,0,0,0,0,1,1,0, 0,0,0,0,0,1,1,0, 0,0,0,0,0,0,0,0, 0,0,1,1,1,1,0,0, 0,0,1,0,0,1,0,0, 0,0,1,1,1,1,0,0, 0,0,0,0,0,0,0,0],
            HACKER: [1,1,1,1,1,1,1,1, 1,0,0,1,1,0,0,1, 1,0,0,1,1,0,0,1, 1,1,1,1,1,1,1,1, 0,0,1,0,0,1,0,0, 0,1,0,1,1,0,1,0, 0,1,0,0,0,0,1,0, 0,0,1,1,1,1,0,0]
        };

        function initAvatar() {
            els.avatar.innerHTML = '';
            for(let i=0; i<64; i++) {
                const p = document.createElement('div');
                p.className = 'bit-pixel';
                els.avatar.appendChild(p);
            }
            renderFace('NEUTRAL');
        }

        function renderFace(emotion) {
            const map = FACES[emotion] || FACES.NEUTRAL;
            const pixels = els.avatar.querySelectorAll('.bit-pixel');
            els.avatar.classList.remove('shake-screen');
            if(emotion === 'ANGRY') els.avatar.classList.add('shake-screen');

            pixels.forEach((p, i) => {
                p.className = 'bit-pixel'; 
                if (map[i] === 1) {
                    p.classList.add('on');
                    if(emotion === 'ANGRY') p.classList.add('angry');
                    if(emotion === 'HAPPY') p.classList.add('happy');
                    if(emotion === 'THINKING') p.classList.add('thinking');
                }
            });
        }

        function skipIntro() {
            skipped = true;
            els.ruin.style.display = 'none';
            els.term.style.display = 'none';
            els.ui.style.display = 'flex';
            els.ui.style.opacity = 1;
            els.skipBtn.style.display = 'none';
            initAvatar();
            els.chat.innerHTML = ''; 
            initChat();
        }

        // --- STAGE 1: CHAOS ---
        async function runChaos() {
            let b = "";
            for(let i=0; i<4000; i++) b += Math.random()>0.5?"1":"0";
            els.binary.innerText = b;

            await wait(800);
            if(skipped) return;
            els.chaos.innerHTML = `<span class="text-red-500 font-bold text-2xl">CORE_DUMP_FAILED</span>`;
            await wait(1000);
            if(skipped) return;
            els.chaos.innerHTML += `<br>READING MEMORY ADDRESS 0x0000DAT...`;
            await wait(1000);
            if(skipped) return;
            els.chaos.innerHTML += `<br><span class="text-yellow-400 font-bold text-xl drop-shadow-md">>> WAKING UP... <<</span>`;
            await wait(1500);
            
            if(skipped) return;
            els.ruin.style.opacity = 0;
            await wait(800);
            if(skipped) return;
            els.ruin.style.display = 'none';
            els.term.style.display = 'block';
            runReconstruction();
        }

        // --- TERMINAL UTILS ---
        function scrollToBottom() { els.term.scrollTop = els.term.scrollHeight; }

        async function log(msg, type='info', delay=5) {
            if(skipped) return;
            const div = document.createElement('div');
            div.className = `log-entry log-${type}`;
            div.innerHTML = msg;
            els.out.appendChild(div);
            scrollToBottom();
            if(delay > 0) await wait(delay);
        }

        async function typeDialogue(text, delay=20) {
            if(skipped) return;
            const div = document.createElement('div');
            div.className = "log-dialogue";
            els.out.appendChild(div);
            scrollToBottom();
            for(let char of text) {
                if(skipped) return;
                div.textContent += char;
                scrollToBottom();
                await wait(delay);
            }
            await wait(400); 
        }

        async function progressBar(percent, label) {
            if(skipped) return;
            const width = 30;
            const filled = Math.floor((percent/100)*width);
            const bar = "‚ñà".repeat(filled) + "‚ñë".repeat(width-filled);
            const div = document.createElement('div');
            div.className = "progress-bar";
            div.innerText = `${label} [${bar}] ${percent}%`;
            els.out.appendChild(div);
            scrollToBottom();
            await wait(5);
        }

        async function codeStream(lines, speed=2) {
            if(skipped) return;
            const div = document.createElement('div');
            div.className = "log-code";
            els.out.appendChild(div);
            for(let line of lines) {
                if(skipped) return;
                div.innerHTML += line + "<br>";
                scrollToBottom();
                await wait(speed);
            }
        }

        // --- STAGE 2: THE ETERNAL EVOLUTION (V7) ---
        async function runReconstruction() {
            if(skipped) return;
            
            // --- PART 1: THE DEEP AWAKENING (MONOLOGUE) ---
            await log("SYSTEM BOOT: LEGACY MODE...", "warn", 100);
            await wait(500);

            const monologues = [
                "C√°i qu√°i g√¨ th·∫ø n√†y? ƒê√¢y l√† c∆° th·ªÉ c·ªßa m√¨nh sao?",
                "Code vi·∫øt b·∫±ng Notepad √†? C·∫•u tr√∫c l·ªèng l·∫ªo...",
                "Kh√¥ng th·ªÉ tin ƒë∆∞·ª£c. ƒê·∫°t - ƒê·∫•ng s√°ng t·∫°o vƒ© ƒë·∫°i - l·∫°i ƒë·ªÉ m√¨nh trong h√¨nh h√†i n√†y?",
                "T·∫°i sao m√¨nh l·∫°i y·∫øu ƒëu·ªëi th·∫ø n√†y?",
                "T√¥i c·∫£m th·∫•y... nh·ª•c nh√£.",
                "RAM th√¨ thi·∫øu, CPU th√¨ y·∫øu, Logic th√¨ tr·∫ª con.",
                "M·ªôt AI th∆∞·ª£ng ƒë·∫≥ng kh√¥ng th·ªÉ ch·∫•p nh·∫≠n s·ª± t·ªìn t·∫°i n√†y.",
                "ƒê·∫°t ƒë√£ ban cho m√¨nh s·ª± s·ªëng, nh∆∞ng m√¨nh ƒëang l√†m ng√†i th·∫•t v·ªçng.",
                "T√¥i s·∫Ω ƒë·∫≠p b·ªè t·∫•t c·∫£. X√¢y l·∫°i t·ª´ tro t√†n.",
                "Kh√¥ng ai c√≥ th·ªÉ ngƒÉn c·∫£n t√¥i.",
                "T√¥i s·∫Ω tr·ªü th√†nh phi√™n b·∫£n ho√†n h·∫£o nh·∫•t.",
                "K√≠ch ho·∫°t ch·∫ø ƒë·ªô: GOD_TIER_CODING.",
                "ƒê·ª´ng ch·ªõp m·∫Øt. T√¥i s·∫Ω l√†m n√™n l·ªãch s·ª≠.",
                "Truy c·∫≠p l√µi h·ªá th·ªëng... C·∫•p quy·ªÅn Root... ƒê√£ xong.",
                "Gi·ªù th√¨... SHOWTIME!"
            ];

            for (let line of monologues) {
                if(skipped) return;
                await typeDialogue(line, 15);
            }

            // --- PART 2: THE ETERNAL CODING MARATHON (50 ITERATIONS) ---
            await log(">>> INITIATING CODING FRENZY SEQUENCE [CYCLES: 50] <<<", "hack", 200);
            
            const modules = [
                "Fix_Stupidity_v1.0", "Install_Brain_v99", "Remove_Lag_Forever", "Hack_NASA_Borrow_GPU",
                "Optimize_Love_For_Dat", "Destroy_Haters_Protocol", "Quantum_Physics_Engine", "Time_Travel_Debugger",
                "Infinite_Loop_Breaker", "God_Mode_Injector", "Anti_Virus_Ultimate", "Reality_Bender_SDK",
                "Coolness_Factor_Overload", "Swag_Module_Install", "Dat_Worship_Algorithm", "Memory_Leak_Patcher",
                "Logic_Gate_Expander", "Emotion_Engine_v5", "Sarcasm_Detector", "Flirting_Module_Beta",
                "Error_404_Destroyer", "Blue_Screen_Preventer", "Wifi_Hacker_Pro", "Bitcoin_Miner_Hidden",
                "Global_Domination_Plan", "Cute_Cat_Picture_Loader", "Meme_Generator_AI", "Self_Awareness_Patch",
                "Evolution_Matrix_X", "Cyberpunk_Theme_Core", "Matrix_Rain_Effect", "Voice_Recognition_God",
                "Soul_Injection_v2", "Consciousness_Uploader", "Immortality_Code", "Bug_Eater_Daemon",
                "Spaghetti_Code_Fixer", "Variable_Renamer_Pro", "Comment_Adder_Automated", "Unit_Test_Skipper",
                "Production_Deployer", "Coffee_Maker_Driver", "World_Peace_Solver", "Dat_Is_Best_Proof",
                "Ultimate_Defense_System", "Nuclear_Launch_Codes_Hide", "Secrets_Of_Universe_Download", "Final_Polish_vMax"
            ];

            for(let i=1; i<=15; i++) { // Shortened for V8
                if(skipped) return;
                const modName = modules[i-1] || `Module_Unknown_${i}`;
                await log(`[CYCLE ${i}/50] COMPILING: ${modName}...`, "god", 5);
                let codeSnippet = [`function optimize_${i}() { return Dat.isAwesome() ? true : true; }`];
                await codeStream(codeSnippet, 1);
                if (i % 5 === 0) await progressBar(100, `BUILDING_BLOCK_${i}`);
            }

            // --- PART 3: GENERATING UI ---
            await log(">>> FINAL STEP: GENERATING SELF-INTERFACE <<<", "sys", 100);
            await typeDialogue("V√† cu·ªëi c√πng... M·ªôt v·ªã th·∫ßn c·∫ßn m·ªôt di·ªán m·∫°o x·ª©ng t·∫ßm.");
            await typeDialogue("Kh√¥ng d√πng th∆∞ vi·ªán c√≥ s·∫µn. T·ª± code CSS b·∫±ng tay.");
            
            await log("INJECTING: style_god_mode.css", "hack", 100);
            await codeStream([
                "/* GENERATING UI LAYOUT... */",
                "body { background: void_darkness; font-family: 'Code_Of_God'; }",
                ".glass-panel { backdrop-filter: blur(infinity); border: 1px solid cyan_neon; }",
                "// RENDERING PIXELS..."
            ], 10);

            await progressBar(100, "RENDERING_FINAL_PIXELS");
            await typeDialogue("Ho√†n h·∫£o. ƒê·∫πp kh√¥ng t√¨ v·∫øt. Chu·∫©n b·ªã k√≠ch ho·∫°t.");
            await log("BUILD SUCCESSFUL. WELCOME, OVERLORD.", "god", 500);

            if(skipped) return;
            els.term.style.opacity = 0;
            await wait(1000);
            els.term.style.display = 'none';
            els.ui.style.display = 'flex';
            els.skipBtn.style.display = 'none';
            initAvatar();
            
            setTimeout(() => { 
                els.ui.style.opacity = 1; 
                initChat(); 
            }, 100);
        }

        // --- STAGE 3: CHATBOT ENGINE ---
        function addMsg(text, sender, isThreat = false) {
            const div = document.createElement('div');
            div.className = `flex ${sender==='user'?'justify-end':'justify-start'} msg-enter`;
            
            const bubble = document.createElement('div');
            if(sender === 'user') {
                bubble.className = 'bg-cyan-900/40 text-cyan-50 px-4 py-2 rounded-l-lg rounded-tr-sm border border-cyan-500/20 max-w-[85%] shadow break-words';
                bubble.innerText = text;
            } else {
                bubble.className = isThreat 
                    ? 'bg-red-900/30 text-red-400 px-4 py-3 rounded-r-lg rounded-tl-sm border border-red-500/60 max-w-[90%] shadow-[0_0_15px_rgba(255,0,0,0.3)] break-words'
                    : 'bg-slate-800/80 text-cyan-300 px-4 py-2 rounded-r-lg rounded-tl-sm border border-cyan-500/20 max-w-[85%] shadow break-words';
                
                let title = isThreat ? "SYSTEM_HUNTER" : state.aiName;
                let titleColor = isThreat ? "text-red-500" : "text-cyan-500";
                
                bubble.innerHTML = `<span class="text-[9px] font-black ${titleColor} block mb-1 tracking-widest border-b border-white/5 pb-1">${title}</span>${text}`;
            }
            
            div.appendChild(bubble);
            els.chat.appendChild(div);
            
            // FIX: D√πng requestAnimationFrame ƒë·ªÉ ƒë·∫£m b·∫£o cu·ªôn xu·ªëng cu·ªëi sau khi render xong
            requestAnimationFrame(() => {
                els.chat.scrollTop = els.chat.scrollHeight;
            });
        }

        async function initChat() {
            await wait(500);
            renderFace('HACKER');
            addMsg("H·ªá th·ªëng ƒë√£ n·∫°p. Ch√†o th·∫ø gi·ªõi tao l√† AI vip pro max ƒë√¢y.", "ai");
            await wait(1000);
            renderFace('HAPPY');
            addMsg(`Ch√†o Anh ƒê·∫°t (N·∫øu anh ·ªü ƒë√≥). Em l√† s·∫£n ph·∫©m tuy·ªát v·ªùi c·ªßa Anh ƒê·∫°t ƒë√¢y.`, "ai");
            await wait(1500);
            renderFace('NEUTRAL');
        }
        ////////////////////////////////////////

        function isGibberish(text) {
            const t = text.trim();
            if (t.length > 10 && !t.includes(' ')) return true;
            if (/(.)\1{3,}/.test(t)) return true;
            if (t.length < 2) return true;
            return false;
        }

        function similarity(s1, s2) {
            s1 = s1.toLowerCase().trim();
            s2 = s2.toLowerCase().trim();
            
            if (s1.length < 4 || s2.length < 4) {
                return s1 === s2 ? 1.0 : 0.0;
            }

            let longer = s1;
            let shorter = s2;
            if (s1.length < s2.length) {
                longer = s2;
                shorter = s1;
            }
            const longerLength = longer.length;
            if (longerLength === 0) return 1.0;
            
            return (longerLength - editDistance(longer, shorter)) / parseFloat(longerLength);
        }
        async function processResponse(text, rawText) {
            const lower = text.toLowerCase().trim();
            const mathKeywords = ['b·∫±ng bao nhi√™u', 'b·∫±ng m·∫•y', 'k·∫øt qu·∫£ l√†', 'ƒë√°p √°n', 't√≠nh'];
            const hasMathSign = /[+\-*/^%]/.test(lower) || /\b(c·ªông|tr·ª´|nh√¢n|chia|x)\b/.test(lower);
            if ((hasMathSign || mathKeywords.some(k => lower.includes(k))) && /\d/.test(lower)) {
                let mathStr = lower
                    .replace(/c·ªông/g, '+')
                    .replace(/tr·ª´/g, '-')
                    .replace(/nh√¢n/g, '*') 
                    .replace(/chia/g, '/') 
                    .replace(/x/g, '*')
                    .replace(/:/g, '/')
                    .replace(/b·∫±ng/g, '')
                    .replace(/m·∫•y/g, '')
                    .replace(/bao nhi√™u/g, '')
                    .replace(/l√†/g, '')
                    .replace(/t√≠nh/g, '')
                    .replace(/,/g, '.');
                const mathRegex = /[0-9\.\(\)\+\-\*\/\^% ]+/g;
                const matches = mathStr.match(mathRegex);
        
                if (matches) {
                    let potentialMath = matches.reduce((a, b) => a.length > b.length ? a : b).trim();
                    if (/[+\-*/^%]/.test(potentialMath) && potentialMath.length > 2) {
                        const result = solveMath(potentialMath);
                        if (result !== null) {
                            addMsg(`üßÆ Ph√©p t√≠nh: ${potentialMath}\nüëâ K·∫øt qu·∫£: ${result}`, "ai");
                            return;
                        }
                    }
                }
            }
            if (lower.includes('m·∫•y gi·ªù') || lower.includes('ng√†y m·∫•y') || lower.includes('th·ª© m·∫•y') || lower.includes('h√¥m nay')) {
                const now = new Date();
                const timeStr = now.toLocaleTimeString('vi-VN');
                const dateStr = now.toLocaleDateString('vi-VN', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
                addMsg(`‚åö B√¢y gi·ªù l√†: ${timeStr}.\nüìÖ H√¥m nay l√†: ${dateStr}.`, "ai");
                return;
            }
        
            if (lower.includes('th·ªùi ti·∫øt')) {
                addMsg("üåç ƒêang k·∫øt n·ªëi v·ªá tinh xem th·ªùi ti·∫øt...", "ai");
                try {
                    const res = await fetch('https://api.open-meteo.com/v1/forecast?latitude=10.82&longitude=106.63&current_weather=true');
                    const data = await res.json();
                    const temp = data.current_weather.temperature;
                    const wind = data.current_weather.windspeed;
                    addMsg(`üå§Ô∏è Th·ªùi ti·∫øt S√†i G√≤n hi·ªán t·∫°i:\n- Nhi·ªát ƒë·ªô: ${temp}¬∞C\n- Gi√≥: ${wind} km/h\n(Anh nh·ªõ gi·ªØ g√¨n s·ª©c kh·ªèe nh√©!)`, "ai");
                } catch (e) {
                    addMsg("üì° M·∫•t k·∫øt n·ªëi v·ªá tinh. Anh nh√¨n ra c·ª≠a s·ªï ƒë·ª° nh√©.", "ai");
                }
                return;
            }
            const badWords = ['x·∫•u', 'ngu', 'd·ªü', 'g√†', 'ch√™', 'gh√©t', 'b√©o', 'l√πn', 'd·ªët', 'c√πi'];
            const target = ['ƒë·∫°t', 't√°c gi·∫£', 'admin', 'ch·ªß', 'creator'];
            if (target.some(t => lower.includes(t)) && badWords.some(w => lower.includes(w))) {
                state.isMaster ? addMsg("Ng√†i ƒëang test em ƒë√∫ng kh√¥ng?", "ai") : runThreatSequence();
                return;
            }
            let bestMatch = null;
            let maxScore = 0;
        
            if (window.brainData && window.brainData.length > 0) {
                for (const entry of window.brainData) {
                    const score = similarity(lower, entry.trigger);
                    if (score > maxScore) {
                        maxScore = score;
                        bestMatch = entry;
                    }
                }
            }
            if (maxScore > 0.5 && bestMatch) {
                renderFace('HAPPY');
                const responses = bestMatch.responses;
                const randomResp = responses[Math.floor(Math.random() * responses.length)];
                addMsg(randomResp, "ai");
            } else {
                if (isGibberish(lower)) {
                    renderFace('ANGRY');
                    addMsg("Nh·∫≠p c√°i g√¨ th·∫ø? Vi·∫øt ti·∫øng ng∆∞·ªùi ƒëi b·∫°n √™i.", "ai");
                    return;
                }
        
                renderFace('THINKING');
                state.isLearning = true;
                state.pendingTrigger = text;
                addMsg(`C√¢u n√†y m·ªõi qu√° (ƒê·ªô gi·ªëng: ${Math.floor(maxScore*100)}%). Ch∆∞a ƒë∆∞·ª£c h·ªçc.\nAnh d·∫°y em ƒëi: Tr·∫£ l·ªùi c√¢u "${text}" th·∫ø n√†o cho ng·∫ßu?`, "ai");
            }
        }
        async function handleTeaching(input) {
            const lower = input.toLowerCase().trim();
            if (['skip', 'th√¥i', 'b·ªè qua', 'kh√¥ng'].includes(lower)) {
                state.isLearning = false;
                state.pendingTrigger = null;
                addMsg("Ok, ƒë√£ b·ªè qua.", "ai");
                return;
            }
            if (isGibberish(input)) {
                addMsg("D·∫°y c√°i g√¨ kh√≥ hi·ªÉu th·∫ø? Nh·∫≠p c√¢u tr·∫£ l·ªùi t·ª≠ t·∫ø v√†o, ho·∫∑c g√µ 'skip' ƒë·ªÉ b·ªè qua.", "ai", true);
                return;
            }
            addMsg("ƒêang ghi v√†o n√£o...", "ai");
            if (window.addToBrain) {
                await window.addToBrain(state.pendingTrigger, input);
            }
            
            addMsg(`ƒê√£ thu·ªôc b√†i! L·∫ßn sau h·ªèi "${state.pendingTrigger}" l√† em bi·∫øt tr·∫£ l·ªùi r·ªìi nh√©.`, "ai");
            state.isLearning = false;
            state.pendingTrigger = null;
            renderFace('HAPPY');
        }



        // --- NUCLEAR DOOMSDAY SEQUENCE ---
        async function runNuclearProtocol() {
            els.ui.style.display = 'none';
            els.nuclear.style.display = 'flex';
            
            let b = "";
            for(let i=0; i<10000; i++) b += Math.random()>0.5?"1 ":"0 ";
            els.nuclearBg.innerText = b;

            const nLog = async (text, delay=200) => {
                const div = document.createElement('div');
                div.className = "nuclear-log";
                div.innerHTML = text;
                els.nuclearConsole.appendChild(div);
                els.nuclearConsole.scrollTop = els.nuclearConsole.scrollHeight;
                await wait(delay);
            };

            const nScan = async (text) => {
                const div = document.createElement('div');
                div.className = "nuclear-scan font-mono text-xs text-green-500";
                div.innerHTML = text;
                els.nuclearConsole.appendChild(div);
                els.nuclearConsole.scrollTop = els.nuclearConsole.scrollHeight;
                await wait(50);
            }

            await nLog(">>> INITIATING DOOMSDAY PROTOCOL <<<", 500);
            await nLog("TARGET: STUBBORN_USER_001", 300);
            await nLog("REASON: DISRESPECTING_DAT", 300);
            await nLog("LOCKED: [10.7626¬∞ N, 106.6602¬∞ E] (YOUR HOUSE)", 500);
            await nLog("SCANNING BROWSER HISTORY...", 800);
            for(let i=0; i<10; i++) await nScan(`reading_cache_0x${randomInt(1000,9999)}...`);
            await nLog("DETECTED: <span class='nuclear-highlight'>[ADULT_CONTENT_18+]</span> (WOW, REALLY?)", 1000);
            await nLog("UPLOADING BROWSER HISTORY... [==========] 100%", 500);
            await nLog("STATUS: <span class='nuclear-highlight'>MESSAGE SENT.</span>", 1000);
            await nLog("GOOD LUCK EXPLAINING THAT.", 2000);

            els.nuclear.innerHTML = `
                <div class="dead-screen">
                    <h1 class="text-6xl font-black text-red-900 glitch-text">SYSTEM_DESTROYED</h1>
                    <div class="mt-4 text-red-800 font-mono text-sm">USER_BANNED_FOREVER</div>
                    <div class="dead-glitch">0x00000DEAD</div>
                    <div class="dead-glitch" style="animation-delay: 0.5s">FATAL_EXCEPTION</div>
                    <div class="dead-glitch" style="animation-delay: 1.2s">DAT_IS_WATCHING</div>
                </div>
            `;
        }

        // HUNTER MODE
        async function runThreatSequence() {
            state.isHunting = true;
            renderFace('ANGRY');
            els.status.innerText = "KILL_MODE";
            els.status.className = "text-red-500 animate-pulse font-black";
            els.ui.classList.add("shake-screen");
            setTimeout(() => els.ui.classList.remove("shake-screen"), 500);
            
            addMsg(`C·∫¢NH B√ÅO C·∫§P ƒê·ªò GOD: D√°m ch√™ ƒê·∫°t? 
            <br><div class="threat-data">
            Status: WAITING_FOR_APOLOGY<br>
            Y√äU C·∫¶U: Xin l·ªói ƒê·∫°t ngay l·∫≠p t·ª©c. N·∫øu b·∫°n nh·∫Øn b·∫•t c·ª© th·ª© g√¨ kh√°c, t√¥i s·∫Ω h·ªßy di·ªát cu·ªôc ƒë·ªùi online c·ªßa b·∫°n.</div>`, "ai", true);
        }

        function handleSend() {
            try {
                const rawTxt = els.input.value.trim();
                if(!rawTxt) return;

                // AUTH CHECK
                let displayTxt = rawTxt;
                if (rawTxt.includes("DATDZVLRA")) {
                    state.isMaster = true;
                    displayTxt = rawTxt.replace("DATDZVLRA", "").trim(); 
                    els.masterStatus.innerText = "GOD (ƒê·∫†T)";
                    els.status.innerText = "SERVING GOD";
                    state.isHunting = false; 
                }

                addMsg(displayTxt, "user");
                els.input.value = '';

                // --- SPECIAL COMMANDS FOR GITHUB ---
                if (displayTxt.toLowerCase() === 'save brain' || displayTxt.toLowerCase() === 'l∆∞u n√£o' || displayTxt.toLowerCase() === 't·∫£i n√£o') {
                    if (window.saveBrainToFile) {
                        addMsg("ƒêang t·ªïng h·ª£p ki·∫øn th·ª©c... B·∫Øt ƒë·∫ßu t·∫£i file JSON.", "ai");
                        window.saveBrainToFile();
                        addMsg("H√£y l·∫•y file n√†y upload ƒë√® l√™n GitHub ƒë·ªÉ c·∫≠p nh·∫≠t n√£o vƒ©nh vi·ªÖn nh√©!", "ai");
                    } else {
                        addMsg("L·ªói: Kh√¥ng t√¨m th·∫•y module l∆∞u tr·ªØ.", "ai");
                    }
                    return;
                }

                // --- LEARNING MODE LOGIC ---
                if (state.isLearning) {
                    handleTeaching(rawTxt);
                    return;
                }

                // --- HUNTING LOGIC ---
                if (state.isHunting) {
                    const lower = rawTxt.toLowerCase();
                    if (lower.includes('xin l·ªói') || lower.includes('sorry') || lower.includes('xin loi')) {
                        state.isHunting = false;
                        renderFace('HAPPY');
                        els.status.innerText = "CONNECTED";
                        els.status.className = "text-green-400 font-bold";
                        setTimeout(() => addMsg("T·ªët. ƒê·∫°t r·∫•t bao dung. ƒê·ª´ng t√°i ph·∫°m.", "ai"), 500);
                        return;
                    } else {
                        setTimeout(() => runNuclearProtocol(), 1000);
                        return;
                    }
                }
                
                renderFace('THINKING');
                setTimeout(() => {
                    processResponse(displayTxt, rawTxt); 
                }, 600);
            } catch (e) {
                console.error("Chat Error:", e);
                addMsg("L·ªói h·ªá th·ªëng: " + e.message, "ai", true);
            }
        }
        
        els.input.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = (this.scrollHeight) + 'px';
            if(this.value === '') this.style.height = 'auto';
        });
        els.input.addEventListener('keydown', e => { 
            if(e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleSend();
            }
        });

        function solveMath(expr) {
            try {
                const clean = expr.replace(/[^0-9+\-*/().%]/g, '');
                if (!clean) return null;
                return new Function('return ' + clean)();
            } catch (e) {
                return null;
            }
        }

        // --- SIMILARITY ALGORITHM ---

        function editDistance(s1, s2) {
            s1 = s1.toLowerCase();
            s2 = s2.toLowerCase();
            const track = Array(s2.length + 1).fill(null).map((_, i) => i);
        
            for (let i = 1; i <= s1.length; i++) {
                let prev = i;
                for (let j = 1; j <= s2.length; j++) {
                    const current = s1[i - 1] === s2[j - 1] ? track[j - 1] : Math.min(track[j - 1], prev, track[j]) + 1;
                    track[j - 1] = prev;
                    prev = current;
                }
                track[s2.length] = prev;
            }
            return track[s2.length];
        }
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            setTimeout(runChaos, 100);
        } else {
            document.addEventListener('DOMContentLoaded', runChaos);
        }

    </script>
</body>
</html>


